# 정렬 알고리즘

전제 : 중복 key없다. 오름차순 정렬이다.

### 정렬이란?

원소들이 순서대로 배열되어 있다.

해당 원소가 제자리에 있다. 


### 정렬 알고리즘의 종류

****************************bubble sort**************************** 

**********[시간복잡도]********** 항상 O(n^2)

  **[아이디어]** pass마다 list의 가벼운 원소들을 왼쪽으로 밀어낸다. 결과적으로 무거운 원소들순으로 뒤부터 정렬된다.

  ******[구체적 동작]****** pass는 전체 배열의 0번 idx부터 시작하며, 이웃한 원소의 비교로 더 작은 원소를 왼쪽으로 밀어낸다.

  **[모양]**

  결과적으로 pass마다 가장 무거운 원소가 sublist의 가장 뒤에 위치한다.

  가벼운 원소들이 거품처럼 위로 올라온다.
	
---
****************************selection sort****************************

  **********[시간복잡도]********** $O(n^2)$_항상

  **[아이디어]** pass마다 ****자리에 알맞은 원소를 input에서 찾는다. 전체적으로는 N번째 자리에 입력값들 중 N번째로 큰 숫자를 넣는다.

  **[구체적 동작]** 해당 pass에서 가장 작은 원소를 찾아내 sublist의 첫 번째 원소와 swap한다.

  **[모양]** 앞 자리부터 정렬된다.

  ****************[특징]**************** input insensitive(입력에 둔감하다).
	
---

****************************insertion sort****************************

  **********[시간복잡도]********** $O(n^2)$

  ********************************************[아이디어]******************************************** 한 개 원소가 정렬된 sublist 사이의 자신 위치로 찾아간다. 

   **[구체적 동작]** 해당 pass의 원소가 자신보다 작은 원소와 자신보다 큰 원소 사이의 위치로 한 칸씩 이동한다.

  **[모양]** 정렬된 sublist의 크기가 하나씩 늘어난다.

  ****************[특징]**************** 

  input sensitive(입력에 민감하다).

  ****************************************************************[시간복잡도 부연설명]****************************************************************
  
  최악은 맨 뒤의 원소를 맨 앞으로 보내줄 때이므로, $O(n^2)$

---
  
********************shell sort********************

  **********[시간복잡도]********** $O(n^2)$ → $O(n^(1.25))$

  ********************************************[아이디어]******************************************** 빠른 정렬을 위해, 뭉텅이로 정렬한다.

  **[구체적 동작]** pass마다 ****gap값을 지정해 input을 grouping하고, selection sort를 이용해 각 그룹을 정렬한 후 merge한다. gap를 줄이고 다시 반복한다.

  **[모양]** 점차 구멍 크기를 줄이며 채를 흔드는 것처럼 보인다.

  ****************[특징]**************** 

  insertion sort를 보완한 알고리즘 
  
  - insertion sort의 문제 : 삽입을 위해 많은 이동을 요구
  - insertion sort와 비교 : shell sort는 한 번에 정렬하지 않는다.
  
  input sensitive(입력에 민감하다).
  
  gap의 값에 따라 성능이 좌우된다. 그러나 최적 gap값은 모른다.
  
  ****************************************************************[시간복잡도 부연설명]****************************************************************
  
  $O(n^(1.25))$는 실험 결과에 따른 것이다.
  
  최적 gap값은 모른다.

**shell sort 부연 설명**

작은 크기의 입력에 매우 좋은 성능을 보이고(input sensitive) parellel한 방식에 적합하므로, embedded system에서 많이 쓰인다.

---
